<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jace Multisend - X Layer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="icon" href="https://woofingjace.com/images/jace.png" type="image/x-icon">
    <style>
        /* Existing CSS remains unchanged */
        .error { color: #FF5252; font-weight: 600; }
        .loading-spinner { display: inline-block; width: 16px; height: 16px; border: 2px solid #00BFA5; border-radius: 50%; border-top-color: transparent; animation: spin 1s linear infinite; margin-left: 8px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <h1>Jace Multisend</h1>
        <div class="section">
            <h2>Connect to X Layer</h2>
            <button id="connectButton" class="button">Connect Wallet</button>
            <p>Wallet: <span id="walletAddress" class="wallet-info">Not connected</span></p>
            <div id="networkStatus" class="status">Click to connect...</div>
        </div>
        <div class="section" id="multisendSection">
            <h2>Batch Transfer</h2>
            <select id="transferType" onchange="toggleTokenAddress()">
                <option value="OKB">OKB (X Layer Mainnet Coin)</option>
                <option value="Token">Token</option>
            </select>
            <input type="text" id="tokenAddress" placeholder="Token Address (e.g., 0x...)" style="display: none;" oninput="debouncedFetchTokenInfo()">
            <div id="tokenInfo" class="token-info"></div>
            <textarea id="transferList" placeholder="Enter addresses and amounts (e.g., 0xfb10e2b3f29931f8372680877f1e4b3a139d9fa3,10000\n0xb82b803105107dd873baa9e61435d4710b531d6b,11000)"></textarea>
            <button id="sendBatch" class="button">Send Batch Transfer</button>
            <div id="multisendStatus" class="status"></div>
            <table class="token-table">
                <thead>
                    <tr>
                        <th>Coin</th>
                        <th>Address</th>
                        <th>Amount</th>
                    </tr>
                </thead>
                <tbody id="transferPreview"></tbody>
            </table>
        </div>
        <div class="how-it-works">
            <h2>How It Works?</h2>
            <p>Send OKB or tokens to multiple addresses on X Layer with Jace Multisend:</p>
            <ul>
                <li><strong>Connect Your Wallet</strong>: Use MetaMask to connect to X Layer (chain ID: 196). Ensure you have enough <span class="highlight">OKB</span> for gas fees.</li>
                <li><strong>Select Transfer Type</strong>: Choose <span class="highlight">OKB</span> for mainnet coin or <span class="highlight">Token</span> for ERC20 tokens.</li>
                <li><strong>Enter Token Address</strong>: If transferring tokens, input a valid ERC20 token contract address to see its symbol, name, and your balance.</li>
                <li><strong>Input Addresses & Amounts</strong>: Enter one address and amount per line (e.g., <span class="highlight">0x...address,10000</span>). Supports up to 200 addresses.</li>
                <li><strong>Send Batch</strong>: Click to approve (if tokens) and execute the transfer in one go.</li>
            </ul>
        </div>
        <div class="footer">
            Powered by <a href="https://www.okx.com/web3/explorer/xlayer" target="_blank">X Layer</a> | Jace Multisend © 2025
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script>
        let web3, accounts, multisendContract;
        const multisendAddress = "0xa0efAC6b1096a4D2C40BFb2a32dC2AF71a45A9F8";
        const OKB_LOGO = "https://static.oklink.com/cdn/assets/imgs/243/230501A8Eಸ0E74482AB.png";
        const MAX_UINT256 = '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';

        const multisendABI = [ /* Unchanged ABI */ ];
        const tokenABI = [ /* Unchanged ABI */ ];

        const xLayer = { chainId: 196, name: 'X Layer mainnet', explorerUrl: 'https://www.okx.com/web3/explorer/xlayer', rpcUrl: 'https://rpc.xlayer.tech' };

        // Debounce function to limit API calls
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        async function connectWallet() {
            const status = document.getElementById('networkStatus');
            const sendButton = document.getElementById('sendBatch');
            try {
                if (!window.ethereum) throw new Error("No wallet detected. Install MetaMask.");
                status.textContent = "Connecting...";
                web3 = new Web3(window.ethereum);
                accounts = await web3.eth.requestAccounts();
                const chainId = await web3.eth.getChainId();
                if (chainId !== 196) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0xc4' }],
                        });
                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [{
                                    chainId: '0xc4',
                                    chainName: xLayer.name,
                                    rpcUrls: [xLayer.rpcUrl],
                                    nativeCurrency: { name: 'OKB', symbol: 'OKB', decimals: 18 },
                                    blockExplorerUrls: [xLayer.explorerUrl],
                                }],
                            });
                        } else {
                            throw switchError;
                        }
                    }
                }
                document.getElementById('walletAddress').textContent = `${accounts[0].slice(0, 6)}...${accounts[0].slice(-4)}`;
                multisendContract = new web3.eth.Contract(multisendABI, multisendAddress);
                status.textContent = "Connected to X Layer";
                sendButton.disabled = false;
                console.log("Wallet connected:", accounts[0]);
                fetchTokenInfo();
            } catch (error) {
                console.error("Connect error:", error);
                status.textContent = `Connection failed: ${error.message}`;
                sendButton.disabled = true;
            }
        }

        function toggleTokenAddress() {
            const transferType = document.getElementById('transferType').value;
            const tokenAddressInput = document.getElementById('tokenAddress');
            const tokenInfoDiv = document.getElementById('tokenInfo');
            tokenAddressInput.style.display = transferType === 'Token' ? 'block' : 'none';
            tokenInfoDiv.textContent = '';
            parseTransferList();
            if (transferType === 'Token') debouncedFetchTokenInfo();
        }

        async function fetchTokenInfo() {
            const transferType = document.getElementById('transferType').value;
            const tokenInfoDiv = document.getElementById('tokenInfo');
            const tokenAddressInput = document.getElementById('tokenAddress');
            tokenInfoDiv.innerHTML = '';
            if (transferType !== 'Token' || !accounts || !web3) return;

            const tokenAddress = tokenAddressInput.value.trim();
            if (!web3.utils.isAddress(tokenAddress)) {
                tokenInfoDiv.innerHTML = '<span class="error">Invalid token address</span>';
                return;
            }

            tokenInfoDiv.innerHTML = 'Fetching token info... <span class="loading-spinner"></span>';
            try {
                // Check if the address is a contract
                const code = await web3.eth.getCode(tokenAddress);
                if (code === '0x') {
                    tokenInfoDiv.innerHTML = '<span class="error">Address is not a contract</span>';
                    return;
                }

                const tokenContract = new web3.eth.Contract(tokenABI, tokenAddress);
                const [symbol, name, decimals, balanceWei] = await Promise.all([
                    tokenContract.methods.symbol().call().catch(() => 'Unknown'),
                    tokenContract.methods.name().call().catch(() => 'Unknown Token'),
                    tokenContract.methods.decimals().call().catch(() => 18),
                    tokenContract.methods.balanceOf(accounts[0]).call().catch(() => '0'),
                ]);

                if (symbol === 'Unknown' && name === 'Unknown Token') {
                    tokenInfoDiv.innerHTML = '<span class="error">Invalid ERC20 token contract</span>';
                    return;
                }

                const balance = web3.utils.fromWei(balanceWei, decimals === 18 ? 'ether' : { unit: 'wei', decimals });
                tokenInfoDiv.innerHTML = `Token: <span>${symbol}</span> (${name}), Balance: <span>${parseFloat(balance).toFixed(4)}</span>`;

                // Update transfer list parsing with correct decimals
                parseTransferList();
            } catch (error) {
                console.error("Token info error:", error);
                tokenInfoDiv.innerHTML = `<span class="error">Failed to fetch token info: ${error.message}</span>`;
            }
        }

        const debouncedFetchTokenInfo = debounce(fetchTokenInfo, 500);

        function parseTransferList() {
            const transferList = document.getElementById('transferList').value.trim();
            const transferType = document.getElementById('transferType').value;
            const lines = transferList.split('\n').map(line => line.trim()).filter(line => line);
            const transfers = [];
            const previewBody = document.getElementById('transferPreview');
            previewBody.innerHTML = '';

            if (lines.length > 200) {
                alert("Maximum 200 addresses allowed!");
                return null;
            }

            let totalAmount = web3.utils.toBN(0);
            let symbol = 'OKB';
            let decimals = 18;
            let logo = OKB_LOGO;

            if (transferType === 'Token') {
                const tokenAddress = document.getElementById('tokenAddress').value.trim();
                if (!web3.utils.isAddress(tokenAddress)) {
                    alert("Invalid token address!");
                    return null;
                }
                // Use cached token info if available
                const tokenInfoDiv = document.getElementById('tokenInfo');
                if (tokenInfoDiv.textContent.includes('Token:')) {
                    const match = tokenInfoDiv.textContent.match(/Token: (\w+)/);
                    if (match) symbol = match[1];
                    const decimalsMatch = tokenInfoDiv.textContent.match(/Decimals: (\d+)/);
                    if (decimalsMatch) decimals = parseInt(decimalsMatch[1]);
                }
                logo = `https://ui-avatars.com/api/?name=${symbol[0]}&background=00BFA5&color=121212&size=24`;
            }

            for (const line of lines) {
                const [address, amountStr] = line.split(',').map(item => item.trim());
                if (!web3.utils.isAddress(address)) {
                    alert(`Invalid address: ${address}`);
                    return null;
                }
                const amount = parseFloat(amountStr);
                if (isNaN(amount) || amount <= 0) {
                    alert(`Invalid amount for address ${address}: ${amountStr}`);
                    return null;
                }
                const amountWei = web3.utils.toWei(amountStr, decimals === 18 ? 'ether' : { unit: 'wei', decimals });
                transfers.push({ address, amount: amountWei });
                const row = document.createElement('tr');
                row.innerHTML = `<td><img src="${logo}" class="token-img">${symbol}</td><td>${address.slice(0, 6)}...${address.slice(-4)}</td><td>${amount}</td>`;
                previewBody.appendChild(row);
                totalAmount = totalAmount.add(web3.utils.toBN(amountWei));
            }
            return { transfers, totalAmount, symbol, decimals };
        }

        async function sendBatchTransfer() {
            const section = document.getElementById('multisendSection');
            const status = document.getElementById('multisendStatus');
            const sendButton = document.getElementById('sendBatch');

            if (!web3 || !accounts) {
                alert("Connect wallet first!");
                status.textContent = "Wallet not connected";
                return;
            }

            const parsed = parseTransferList();
            if (!parsed) {
                status.textContent = "Invalid transfer list";
                return;
            }
            const { transfers, totalAmount, symbol, decimals } = parsed;
            if (transfers.length === 0) {
                alert("No transfers provided!");
                status.textContent = "No transfers to process";
                return;
            }

            try {
                section.classList.add('loading');
                sendButton.disabled = true;
                status.textContent = "Preparing...";
                console.log("Transfers:", transfers);

                const gasPrice = await web3.eth.getGasPrice();
                const adjustedGasPrice = web3.utils.toBN(gasPrice).mul(web3.utils.toBN(15)).div(web3.utils.toBN(10));
                const transferType = document.getElementById('transferType').value;
                const targets = transfers.map(t => t.address);
                const amounts = transfers.map(t => t.amount);
                const gasLimit = 200000 + (transfers.length * 50000);

                if (transferType === 'Token') {
                    const tokenAddress = document.getElementById('tokenAddress').value.trim();
                    const tokenContract = new web3.eth.Contract(tokenABI, tokenAddress);
                    status.textContent = "Checking allowance...";
                    const allowance = await tokenContract.methods.allowance(accounts[0], multisendAddress).call();
                    if (web3.utils.toBN(allowance).lt(totalAmount)) {
                        status.textContent = "Approving tokens...";
                        await tokenContract.methods.approve(multisendAddress, MAX_UINT256).send({
                            from: accounts[0],
                            gas: 100000,
                            gasPrice: adjustedGasPrice
                        });
                        status.textContent = "Approval done, sending...";
                    }
                    status.textContent = "Sending token batch...";
                    await multisendContract.methods.multisendToken(tokenAddress, targets, amounts).send({
                        from: accounts[0],
                        gas: gasLimit,
                        gasPrice: adjustedGasPrice
                    });
                } else {
                    status.textContent = "Sending OKB batch...";
                    await multisendContract.methods.multisendEth(targets, amounts).send({
                        from: accounts[0],
                        value: totalAmount,
                        gas: gasLimit,
                        gasPrice: adjustedGasPrice
                    });
                }
                status.textContent = "Batch transfer successful!";
                document.getElementById('transferList').value = '';
                document.getElementById('transferPreview').innerHTML = '';
                document.getElementById('tokenInfo').textContent = '';
            } catch (error) {
                console.error("Send error:", error);
                status.textContent = `Failed: ${error.message || 'Unknown error'}`;
            } finally {
                section.classList.remove('loading');
                sendButton.disabled = false;
            }
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => alert("Copied!")).catch(err => console.error("Copy error:", err));
        }

        document.getElementById('connectButton').addEventListener('click', connectWallet);
        document.getElementById('sendBatch').addEventListener('click', sendBatchTransfer);
        document.getElementById('transferList').addEventListener('input', parseTransferList);

        window.addEventListener('load', () => {
            document.getElementById('sendBatch').disabled = true;
            if (!window.location.protocol.startsWith('http')) {
                document.getElementById('networkStatus').textContent = 'Run via local server (e.g., npx serve)';
            } else if (!window.ethereum) {
                document.getElementById('networkStatus').textContent = 'Install MetaMask';
            }
        });
    </script>
</body>
</html>
