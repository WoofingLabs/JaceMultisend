<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JaceSwap - Swap</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #00BFA5;
            --secondary-color: #009688;
            --gradient-bg: linear-gradient(180deg, #121212 0%, #1A1A1A 100%);
            --card-bg: #222222;
            --input-bg: #2A2A2A;
            --text-color: #E6E6E6;
            --border-radius: 12px;
        }
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Inter', sans-serif;
            background: var(--gradient-bg);
            color: var(--text-color);
            padding: 20px;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1.5;
        }
        .container {
            width: 100%;
            max-width: 480px;
            background: var(--card-bg);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            border-radius: var(--border-radius);
            padding: 20px;
            position: relative;
        }
        .header {
            background: linear-gradient(90deg, var(--secondary-color) 0%, var(--primary-color) 100%);
            padding: 12px;
            border-radius: var(--border-radius);
            text-align: center;
            font-size: clamp(1.2em, 3.5vw, 1.6em);
            font-weight: 700;
            margin-bottom: 20px;
            text-transform: uppercase;
        }
        .connect-section button {
            padding: 12px;
            background: var(--primary-color);
            color: #121212;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            width: 100%;
            transition: background 0.3s, transform 0.2s;
            margin-bottom: 10px;
        }
        .connect-section button:hover { background: var(--secondary-color); transform: translateY(-2px); }
        .connect-section button:disabled { background: #444; color: #777; cursor: not-allowed; }
        .swap-box {
            background: var(--input-bg);
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 15px;
            border: 1px solid var(--primary-color);
        }
        .balance-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            margin-bottom: 5px;
            color: var(--primary-color);
        }
        .token-search {
            display: flex;
            align-items: center;
            padding: 10px;
            background: var(--card-bg);
            border-radius: 8px;
            margin-bottom: 10px;
            border: 1px solid var(--primary-color);
        }
        .token-search input {
            flex: 1;
            padding: 10px;
            background: var(--input-bg);
            border: none;
            border-radius: 6px;
            color: var(--text-color);
            font-size: 1em;
            margin-right: 10px;
        }
        .token-search input::placeholder { color: #666; }
        .token-search button {
            padding: 10px;
            background: var(--primary-color);
            color: #121212;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s, transform 0.2s;
        }
        .token-search button:hover { background: var(--secondary-color); transform: translateY(-2px); }
        .token-info {
            display: flex;
            align-items: center;
            padding: 10px;
            background: var(--card-bg);
            border-radius: 8px;
            margin-bottom: 10px;
            border: 1px solid var(--primary-color);
        }
        .token-info .avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
            font-size: 0.9em;
            color: var(--primary-color);
        }
        .token-info .avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }
        .token-info .avatar.text {
            background: #333;
        }
        .token-info span { font-size: 1em; }
        input.amount {
            width: 100%;
            padding: 12px;
            background: var(--input-bg);
            border: 1px solid var(--primary-color);
            border-radius: 6px;
            color: var(--text-color);
            font-size: 1em;
            text-align: right;
        }
        .percentage-buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }
        .percentage-buttons button {
            padding: 8px;
            background: #333;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            color: var(--text-color);
            flex: 1;
            font-weight: 600;
            transition: background 0.3s;
        }
        .percentage-buttons button:hover { background: #3A3A3A; }
        .switch-button {
            text-align: center;
            margin: 15px 0;
        }
        .switch-button button {
            padding: 10px;
            background: var(--primary-color);
            color: #121212;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.3s, transform 0.2s;
        }
        .switch-button button:hover { background: var(--secondary-color); transform: translateY(-2px); }
        .swap-button {
            padding: 15px;
            background: var(--primary-color);
            color: #121212;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 600;
            width: 100%;
            transition: background 0.3s, transform 0.2s;
        }
        .swap-button:disabled { background: #444; color: #777; cursor: not-allowed; }
        .swap-button:hover:not(:disabled), .switch-button button:hover { background: var(--secondary-color); transform: translateY(-2px); }
        .status {
            margin-top: 10px;
            font-size: 0.9em;
            color: var(--primary-color);
            text-align: center;
        }
        .status a { color: var(--primary-color); text-decoration: none; }
        .status a:hover { text-decoration: underline; }
        .slippage-info, .swap-note {
            font-size: 0.9em;
            color: var(--primary-color);
            margin-top: 5px;
            text-align: left;
        }
        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #E6E6E6;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 5px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .jace-section {
            text-align: center;
            margin-top: 20px;
        }
        .jace-section .avatar {
            width: 60px;
            height: 60px;
            background: #333;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 10px;
            font-size: 1.5em;
            color: var(--primary-color);
        }
        .jace-message {
            font-size: 0.9em;
            color: var(--secondary-color);
            font-style: italic;
        }
        .loading {
            opacity: 0.7;
            pointer-events: none;
        }
        @media (max-width: 480px) {
            body { padding: 10px; }
            .container { padding: 15px; }
            .header { font-size: 1.4em; }
            .percentage-buttons button { padding: 6px; font-size: 0.9em; }
            .jace-section .avatar { width: 50px; height: 50px; font-size: 1.2em; }
            .jace-message { font-size: 0.85em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">JaceSwap</div>
        <div class="connect-section">
            <button id="connectWalletButton" class="button">Connect Wallet</button>
            <p>Wallet: <span id="walletAddress" class="status">Not connected</span></p>
            <div id="networkStatus" class="status">Click to connect...</div>
        </div>
        <div class="swap-box">
            <div class="balance-row">
                <span>From</span>
                <span id="fromBalance">Balance: 0</span>
            </div>
            <div class="token-info" id="fromTokenInfo">
                <div class="avatar"><img src="https://static.oklink.com/cdn/assets/imgs/243/230501A8E74482AB.png" alt="OKB"></div>
                <span id="fromTokenSymbol">OKB</span>
            </div>
            <input type="number" class="amount" id="fromAmount" placeholder="0.0" step="0.01" oninput="calculateOutput()">
            <div class="percentage-buttons">
                <button onclick="setPercentage(25)">25%</button>
                <button onclick="setPercentage(50)">50%</button>
                <button onclick="setPercentage(75)">75%</button>
                <button onclick="setPercentage(100)">MAX</button>
            </div>
        </div>
        <div class="switch-button">
            <button onclick="switchTokens()">↓↑</button>
        </div>
        <div class="swap-box">
            <div class="balance-row">
                <span>To</span>
                <span id="toBalance">Balance: 0</span>
            </div>
            <div class="token-search" id="toToken">
                <input type="text" id="toTokenAddress" placeholder="Enter token address">
                <button id="toSearchButton">Search</button>
            </div>
            <div class="token-info" id="toTokenInfo">
                <div class="avatar text">?</div>
                <span>Select a token</span>
            </div>
            <div class="slippage-info">Default Slippage: 0.5%</div>
            <div class="swap-note" id="swapNote">Amount automatically calculated by JaceSwap</div>
        </div>
        <button class="swap-button" id="swapButton" onclick="swapTokens()">Swap</button>
        <div class="jace-section">
            <div class="avatar">🟠</div>
            <div class="jace-message" id="jaceMessage">Yo, connect your wallet to dive into JaceSwap, fam!</div>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script>
        const okbToken = { 
            address: "0xe538905cf8410324e03A5A23C1c177a474D59b2b", // WOKB for pair interactions
            symbol: "OKB", 
            avatar: '<img src="https://static.oklink.com/cdn/assets/imgs/243/230501A8E74482AB.png" alt="OKB">', 
            isNative: true 
        };
        const routerAddress = "0xc850D2Ae73Cb81E2B74341534094BCcb4a366c24";
        const factoryAddress = "0x65669BB56EcF7A8420e833c23f5d20502F8efB39";
        const wethAddress = "0xe538905cf8410324e03A5A23C1c177a474D59b2b"; // WOKB
        const flatFee = web3.utils.toWei("0.001", "ether"); // 0.001 BONE
        const routerAbi = [
            {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"payable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactETHForTokens","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"payable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForETH","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"payable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForTokensSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"payable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactETHForTokensSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"payable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swapExactTokensForETHSupportingFeeOnTransferTokens","outputs":[],"stateMutability":"payable","type":"function"},
            {"inputs":[{"internalType":"uint256","name":"amountIn","type":"uint256"},{"internalType":"address[]","name":"path","type":"address[]"}],"name":"getAmountsOut","outputs":[{"internalType":"uint256[]","name":"amounts","type":"uint256[]"}],"stateMutability":"view","type":"function"}
        ];
        const factoryAbi = [
            {"inputs":[{"internalType":"address","name":"tokenA","type":"address"},{"internalType":"address","name":"tokenB","type":"address"}],"name":"getPair","outputs":[{"internalType":"address","name":"pair","type":"address"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"lpInfo","outputs":[{"internalType":"address","name":"_treasury","type":"address"},{"internalType":"uint256","name":"_lpFee","type":"uint256"},{"internalType":"uint256","name":"_woofFee","type":"uint256"},{"internalType":"uint256","name":"_flatFee","type":"uint256"}],"stateMutability":"view","type":"function"}
        ];
        const pairAbi = [
            {"inputs":[],"name":"getReserves","outputs":[{"internalType":"uint112","name":"reserve0","type":"uint112"},{"internalType":"uint112","name":"reserve1","type":"uint112"},{"internalType":"uint32","name":"blockTimestampLast","type":"uint32"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"token0","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"token1","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}
        ];
        const erc20Abi = [
            {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"},
            {"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"success","type":"bool"}],"type":"function"},
            {"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"remaining","type":"uint256"}],"type":"function"},
            {"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"type":"function"},
            {"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"type":"function"}
        ];
        const xLayer = {
            chainId: 196,
            chainName: 'X Layer mainnet',
            nativeCurrency: { name: 'OKB', symbol: 'OKB', decimals: 18 },
            rpcUrls: ['https://rpc.xlayer.tech'],
            blockExplorerUrls: ['https://www.okx.com/web3/explorer/xlayer']
        };
        let web3, account, router, factory;
        let fromToken = okbToken;
        let toToken = null;
        let fromBalance = '0';
        let isFromOKB = true;
        let isApproving = false;
        const defaultSlippage = 0.005;
        const maxPriceImpact = 0.5;

        const jaceMessages = {
            connectStart: ["Yo, Jace is syncing your wallet, hang tight!", "Jace is plugging into X Layer, gimme a sec!", "Hold up, Jace is linking your wallet, fam!", "Jace is locking in your wallet, stay sharp!"],
            connectSuccess: ["Jace got you connected, let’s swap some tokens!", "Yo, you’re in with Jace! Time to make moves!", "Jace linked up, ready to trade like a pro!", "Connected! Jace is set to dominate the swap game!"],
            connectFail: ["Uh-oh, Jace couldn’t link the wallet, try again!", "Wallet’s playing hide and seek, Jace says retry!", "Jace hit a snag, reconnect that wallet, fam!", "Nope, wallet’s offline, Jace needs another shot!"],
            tokenSearch: ["Jace is scanning for that token, hold on!", "Searching the blockchain, Jace’s got this!", "Jace is digging for your token, one sec!", "Token hunt is on, Jace is tracking it down!"],
            selectToken: (symbol) => [`Jace approves of ${symbol}, solid pick!`, `${symbol}? Jace likes your style, let’s trade!`, `Yo, ${symbol} is the vibe, Jace is ready!`, `${symbol} locked in, Jace says it’s go time!`],
            switchTokens: ["Jace is flipping the tokens, smooth move!", "Swapping sides? Jace’s got the switch covered!", "Jace says flip it, let’s change the game!", "Token switch? Jace is all over it, fam!"],
            setPercentage: (percent) => [`Jace is betting ${percent}%, bold move!`, `${percent}%? Jace respects the hustle!`, `Jace is rolling with ${percent}%, let’s do this!`, `${percent}% locked in, Jace is hyped!`],
            calcStart: ["Jace is crunching the numbers, hold tight!", "Calculating the swap, Jace is on it!", "Jace is working the math, give it a sec!", "Price check in progress, Jace is computing!"],
            calcSuccess: (amount, symbol) => [`Jace scored ${amount} ${symbol}, ready to swap?`, `Boom, Jace got you ${amount} ${symbol}!`, `Jace nailed it: ${amount} ${symbol}, let’s trade!`, `${amount} ${symbol} locked in, Jace is pumped!`],
            calcFail: ["Jace couldn’t find a path, try another pair!", "Swap route’s a bust, Jace says pick again!", "No deal here, Jace needs a new token pair!", "Jace hit a wall, retry with different tokens!"],
            swapStart: ["Jace is executing the swap, let’s roll!", "Swap’s on, Jace is making it happen!", "Jace is diving into the trade, hold up!", "Trading time, Jace is running the show!"],
            swapSuccess: ["Jace nailed the swap, you’re a legend!", "Swap complete, Jace says you’re killing it!", "Jace pulled it off, trade’s a success!", "Done deal, Jace made it happen, fam!"],
            swapFail: ["Swap didn’t go through, Jace says try again!", "Jace hit a glitch, let’s retry the trade!", "Trade failed, Jace needs another shot!", "Something broke, Jace says give it one more go!"],
            swapNoToken: ["Jace needs a token to swap, pick one!", "No token? Jace can’t swap air, fam!", "Yo, Jace says select a token first!", "Jace is waiting, choose a token to trade!"],
            swapNoAmount: ["Jace needs an amount, enter something!", "No amount? Jace can’t work with zero!", "Yo, give Jace a number to swap, fam!", "Jace says fill in the amount, let’s go!"],
            highPriceImpact: ["Jace warns: price impact’s too high, scale it down!", "Too much impact, Jace says try a smaller amount!", "Swap’s too big, Jace suggests lowering it!", "Price impact’s wild, Jace says reduce it!"],
            insufficientLiquidity: ["Jace says the pool’s too dry for this swap!", "Not enough liquidity, Jace needs a smaller trade!", "Pool’s empty, Jace says try less!", "Jace can’t swim here, too little liquidity!"],
            approving: ["Jace is approving your tokens, one sec!", "Token approval in progress, Jace’s on it!", "Jace is setting up the trade, hold tight!", "Authorizing tokens, Jace is locking it in!"],
            userDenied: ["Yo, you bailed on Jace! Approve next time!", "Jace was ready, but you said no, retry!", "Denied the trade? Jace says try again!", "Jace got rejected, let’s do this again!"],
            invalidToken: ["Jace says that token’s no good, try another!", "Invalid address, Jace needs a real token!", "Jace can’t find that token, check the address!", "Bad token, Jace says enter a valid one!"]
        };

        function getRandomMessage(type, param1, param2) {
            const messages = jaceMessages[type];
            if (typeof messages === 'function') {
                const options = messages(param1, param2);
                return options[Math.floor(Math.random() * options.length)];
            }
            return messages[Math.floor(Math.random() * messages.length)];
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('connectWalletButton').addEventListener('click', connectWallet);
            document.getElementById('toSearchButton').addEventListener('click', () => searchToken('to'));
            setupWalletListeners();
            if (!window.location.protocol.startsWith('http')) {
                document.getElementById('networkStatus').innerHTML = 'Please run via a local server (e.g., "npx serve").';
            } else if (!window.ethereum) {
                document.getElementById('networkStatus').innerHTML = 'No wallet detected. Install <a href="https://metamask.io" target="_blank">MetaMask</a> or use <a href="https://www.okx.com/web3" target="_blank">OKX Wallet</a>.';
            }
        });

        async function connectWallet() {
            const section = document.getElementById('connect-section');
            const status = document.getElementById('networkStatus');
            const connectButton = document.getElementById('connectWalletButton');
            const jaceMessage = document.getElementById('jaceMessage');
            try {
                if (!window.ethereum) {
                    status.innerHTML = 'No wallet detected. Install <a href="https://metamask.io" target="_blank">MetaMask</a> or <a href="https://www.okx.com/web3" target="_blank">OKX Wallet</a>.';
                    throw new Error("No wallet detected");
                }
                section.classList.add('loading');
                connectButton.disabled = true;
                status.innerText = "Connecting...";
                jaceMessage.innerText = getRandomMessage('connectStart');
                web3 = new Web3(window.ethereum);
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (!accounts.length) {
                    throw new Error("Please unlock your wallet or connect it.");
                }
                account = accounts[0];
                const chainId = await web3.eth.getChainId();
                if (chainId !== 196) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: '0xc4' }]
                        });
                    } catch (switchError) {
                        if (switchError.code === 4902) {
                            await window.ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [xLayer]
                            });
                        } else {
                            throw switchError;
                        }
                    }
                }
                router = new web3.eth.Contract(routerAbi, routerAddress);
                factory = new web3.eth.Contract(factoryAbi, factoryAddress);
                updateUIAfterConnect();
                await updateBalances();
            } catch (error) {
                console.error("Wallet connection error:", error);
                status.innerText = "Failed to connect: " + error.message;
                jaceMessage.innerText = getRandomMessage('connectFail');
                if (error.code === -32002) {
                    status.innerText = "Wallet request pending. Check your wallet extension.";
                } else if (error.message.includes("network")) {
                    status.innerText = "Network error. Try switching to X Layer manually.";
                }
            } finally {
                section.classList.remove('loading');
                connectButton.disabled = false;
            }
        }

        function updateUIAfterConnect() {
            const connectButton = document.getElementById('connectWalletButton');
            const walletAddress = document.getElementById('walletAddress');
            const status = document.getElementById('networkStatus');
            const jaceMessage = document.getElementById('jaceMessage');
            connectButton.innerText = `Connected: ${account.slice(0, 6)}...${account.slice(-4)}`;
            walletAddress.innerText = `${account.slice(0, 6)}...${account.slice(-4)}`;
            status.innerText = "Connected to X Layer";
            jaceMessage.innerText = getRandomMessage('connectSuccess');
        }

        function resetUI() {
            const connectButton = document.getElementById('connectWalletButton');
            const walletAddress = document.getElementById('walletAddress');
            const status = document.getElementById('networkStatus');
            connectButton.innerText = "Connect Wallet";
            walletAddress.innerText = "Not connected";
            status.innerText = "Click to connect...";
        }

        function setupWalletListeners() {
            if (!window.ethereum) return;
            window.ethereum.on('accountsChanged', async (newAccounts) => {
                if (newAccounts.length) {
                    account = newAccounts[0];
                    if (web3) {
                        await connectWallet();
                    } else {
                        await connectWallet();
                    }
                } else {
                    web3 = null;
                    account = null;
                    router = null;
                    factory = null;
                    resetUI();
                    document.getElementById('jaceMessage').innerText = getRandomMessage('connectFail');
                }
            });
            window.ethereum.on('chainChanged', async (chainId) => {
                if (parseInt(chainId, 16) !== 196) {
                    web3 = null;
                    account = null;
                    router = null;
                    factory = null;
                    resetUI();
                    document.getElementById('networkStatus').innerText = "Wrong network. Reconnect to X Layer.";
                    document.getElementById('jaceMessage').innerText = "Jace says: Wrong chain, fam! Switch to X Layer!";
                } else if (account) {
                    await connectWallet();
                }
            });
        }

        async function updateBalances() {
            if (!web3 || !account) return;
            if (fromToken.isNative) {
                fromBalance = await web3.eth.getBalance(account);
                document.getElementById('fromBalance').innerText = `Balance: ${web3.utils.fromWei(fromBalance, 'ether')}`;
            } else {
                const tokenContract = new web3.eth.Contract(erc20Abi, fromToken.address);
                fromBalance = await tokenContract.methods.balanceOf(account).call();
                document.getElementById('fromBalance').innerText = `Balance: ${web3.utils.fromWei(fromBalance, 'ether')}`;
            }
            if (toToken) {
                const toTokenContract = new web3.eth.Contract(erc20Abi, toToken.address);
                const toBalance = await toTokenContract.methods.balanceOf(account).call();
                document.getElementById('toBalance').innerText = `Balance: ${web3.utils.fromWei(toBalance, 'ether')}`;
            }
        }

        async function searchToken(type) {
            const section = document.getElementById('toToken');
            const status = document.getElementById('networkStatus');
            const jaceMessage = document.getElementById('jaceMessage');
            const tokenAddressInput = document.getElementById(`${type}TokenAddress`);
            const tokenAddress = tokenAddressInput.value.trim();
            if (!web3.utils.isAddress(tokenAddress)) {
                status.innerText = "Invalid address!";
                jaceMessage.innerText = getRandomMessage('invalidToken');
                return;
            }
            section.classList.add('loading');
            status.innerText = "Searching token...";
            jaceMessage.innerText = getRandomMessage('tokenSearch');
            try {
                const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);
                let symbol, name;
                try {
                    symbol = await tokenContract.methods.symbol().call();
                    name = await tokenContract.methods.name().call();
                } catch (error) {
                    throw new Error("Failed to fetch token: " + error.message);
                }
                const token = { 
                    address: tokenAddress, 
                    symbol, 
                    avatar: '<div class="text">🔘</div>', 
                    isNative: false 
                };
                if (type === 'to') {
                    toToken = token;
                    document.getElementById('toTokenInfo').innerHTML = `<div class="avatar text">🔘</div><span>${symbol}</span>`;
                    if (isFromOKB) {
                        fromToken = okbToken;
                    } else {
                        fromToken = token;
                        toToken = okbToken;
                        document.getElementById('fromTokenInfo').innerHTML = `<div class="avatar">${okbToken.avatar}</div><span id="fromTokenSymbol">${okbToken.symbol}</span>`;
                    }
                }
                tokenAddressInput.value = '';
                status.innerText = "";
                jaceMessage.innerText = getRandomMessage('selectToken', symbol);
                await updateBalances();
                await calculateOutput();
            } catch (error) {
                status.innerText = "Error: " + (error.message.includes('revert') ? error.message.split('revert')[1]?.trim() : error.message);
                jaceMessage.innerText = getRandomMessage('invalidToken');
            } finally {
                section.classList.remove('loading');
            }
        }

        function switchTokens() {
            const jaceMessage = document.getElementById('jaceMessage');
            const status = document.getElementById('networkStatus');
            if (!toToken) {
                status.innerText = "Please select a token to swap to.";
                jaceMessage.innerText = getRandomMessage('swapNoToken');
                return;
            }
            isFromOKB = !isFromOKB;
            [fromToken, toToken] = [toToken, fromToken];
            document.getElementById('fromTokenInfo').innerHTML = `<div class="avatar">${fromToken.avatar}</div><span id="fromTokenSymbol">${fromToken.symbol}</span>`;
            document.getElementById('toTokenInfo').innerHTML = `<div class="avatar">${toToken.avatar}</div><span>${toToken.symbol}</span>`;
            jaceMessage.innerText = getRandomMessage('switchTokens');
            updateBalances();
            calculateOutput();
        }

        function setPercentage(percentage) {
            const jaceMessage = document.getElementById('jaceMessage');
            const status = document.getElementById('networkStatus');
            if (!fromBalance || !web3) {
                status.innerText = "Please connect wallet first.";
                jaceMessage.innerText = getRandomMessage('connectFail');
                return;
            }
            let amount;
            if (percentage === 100) {
                amount = web3.utils.fromWei(fromBalance, 'ether');
            } else {
                amount = web3.utils.fromWei(fromBalance, 'ether') * (percentage / 100);
            }
            if (percentage === 100 && fromToken.isNative) {
                amount = Math.max(0, amount - 0.01); // Reserve some OKB for gas
            }
            document.getElementById('fromAmount').value = amount.toString();
            jaceMessage.innerText = getRandomMessage('setPercentage', percentage);
            calculateOutput();
        }

        async function calculateOutput() {
            const amountIn = document.getElementById('fromAmount').value;
            const swapNote = document.getElementById('swapNote');
            const jaceMessage = document.getElementById('jaceMessage');
            if (!web3 || !account || !toToken || !amountIn || amountIn <= 0) {
                swapNote.innerHTML = 'Amount automatically calculated by JaceSwap';
                return;
            }
            let amountInWei;
            try {
                amountInWei = web3.utils.toBN(web3.utils.toWei(amountIn, 'ether'));
            } catch (error) {
                swapNote.innerHTML = 'Invalid amount entered.';
                jaceMessage.innerText = getRandomMessage('swapNoAmount');
                return;
            }
            swapNote.innerHTML = `Estimated output: <span class="spinner"></span>`;
            jaceMessage.innerText = getRandomMessage('calcStart');
            try {
                const path = isFromOKB ? [wethAddress, toToken.address] : [fromToken.address, wethAddress];
                const amounts = await router.methods.getAmountsOut(amountInWei, path).call();
                const output = web3.utils.toBN(amounts[amounts.length - 1]);
                if (output.eq(web3.utils.toBN('0'))) {
                    swapNote.innerHTML = 'No valid trading pair found.';
                    jaceMessage.innerText = getRandomMessage('calcFail');
                    return;
                }
                const outputEther = parseFloat(web3.utils.fromWei(output, 'ether'));
                swapNote.innerHTML = `Estimated output: ${outputEther.toFixed(6)} ${toToken.symbol}`;
                jaceMessage.innerText = getRandomMessage('calcSuccess', outputEther.toFixed(2), toToken.symbol);
            } catch (error) {
                console.error("Error calculating output:", error);
                swapNote.innerHTML = 'Error calculating output: ' + (error.message.includes('revert') ? error.message.split('revert')[1]?.trim() : error.message);
                jaceMessage.innerText = getRandomMessage('calcFail');
            }
        }

        async function approveToken(tokenAddress, amount) {
            if (tokenAddress.toLowerCase() === wethAddress.toLowerCase() && fromToken.isNative) return;
            const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);
            const allowance = await tokenContract.methods.allowance(account, routerAddress).call();
            if (web3.utils.toBN(allowance).lt(web3.utils.toBN(amount))) {
                const swapButton = document.getElementById('swapButton');
                const jaceMessage = document.getElementById('jaceMessage');
                const swapSection = document.getElementById('swapButton').parentElement;
                isApproving = true;
                swapButton.innerText = "Authorizing...";
                swapButton.disabled = true;
                jaceMessage.innerText = getRandomMessage('approving');
                swapSection.classList.add('loading');
                try {
                    const gasPrice = await web3.eth.getGasPrice();
                    const adjustedGasPrice = web3.utils.toBN(gasPrice).mul(web3.utils.toBN(15)).div(web3.utils.toBN(10));
                    await tokenContract.methods.approve(routerAddress, amount).send({ from: account, gas: '100000', gasPrice: adjustedGasPrice });
                    document.getElementById('networkStatus').innerText = "Token approved";
                    jaceMessage.innerText = "Jace says: Tokens approved, ready to swap!";
                } catch (error) {
                    jaceMessage.innerText = getRandomMessage('swapFail');
                    throw error;
                } finally {
                    isApproving = false;
                    swapButton.innerText = "Swap";
                    swapButton.disabled = false;
                    swapSection.classList.remove('loading');
                }
            }
        }

        async function swapTokens() {
            const jaceMessage = document.getElementById('jaceMessage');
            const status = document.getElementById('networkStatus');
            const swapButton = document.getElementById('swapButton');
            const swapSection = document.getElementById('swapButton').parentElement;
            if (isApproving) return;
            if (!web3 || !account || !toToken) {
                status.innerText = "Please connect wallet and select tokens.";
                jaceMessage.innerText = getRandomMessage('swapNoToken');
                return;
            }
            const amountIn = document.getElementById('fromAmount').value;
            if (!amountIn || amountIn <= 0) {
                status.innerText = "Please enter a valid amount.";
                jaceMessage.innerText = getRandomMessage('swapNoAmount');
                return;
            }
            let amountInWei;
            try {
                amountInWei = web3.utils.toBN(web3.utils.toWei(amountIn, 'ether'));
            } catch (error) {
                status.innerText = "Invalid amount entered.";
                jaceMessage.innerText = getRandomMessage('swapNoAmount');
                console.error("Amount conversion error:", error);
                return;
            }
            swapSection.classList.add('loading');
            swapButton.disabled = true;
            status.innerText = "Processing swap...";
            jaceMessage.innerText = getRandomMessage('swapStart');
            try {
                const path = isFromOKB ? [wethAddress, toToken.address] : [fromToken.address, wethAddress];
                const amounts = await router.methods.getAmountsOut(amountInWei, path).call();
                const output = web3.utils.toBN(amounts[amounts.length - 1]);
                if (output.eq(web3.utils.toBN('0'))) {
                    status.innerText = "No valid trading pair found.";
                    jaceMessage.innerText = getRandomMessage('calcFail');
                    return;
                }
                const pairAddress = await factory.methods.getPair(path[0], path[1]).call();
                if (pairAddress === '0x0000000000000000000000000000000000000000') {
                    status.innerText = "Trading pair does not exist.";
                    jaceMessage.innerText = getRandomMessage('calcFail');
                    return;
                }
                const pairContract = new web3.eth.Contract(pairAbi, pairAddress);
                const reserves = await pairContract.methods.getReserves().call();
                const token0 = await pairContract.methods.token0().call();
                const reserveFrom = token0.toLowerCase() === path[0].toLowerCase() ? reserves.reserve0 : reserves.reserve1;
                const reserveTo = token0.toLowerCase() === path[0].toLowerCase() ? reserves.reserve1 : reserves.reserve0;
                const reserveFromBN = web3.utils.toBN(reserveFrom);
                const reserveToBN = web3.utils.toBN(reserveTo);
                const priceImpact = amountInWei.mul(web3.utils.toBN(100)).div(reserveFromBN.add(amountInWei));
                if (priceImpact.gt(web3.utils.toBN(maxPriceImpact * 100))) {
                    status.innerText = `Price impact too high (${priceImpact.toString()}%).`;
                    jaceMessage.innerText = getRandomMessage('highPriceImpact');
                    return;
                }
                if (output.gt(reserveToBN)) {
                    status.innerText = `Insufficient liquidity in pool.`;
                    jaceMessage.innerText = getRandomMessage('insufficientLiquidity');
                    return;
                }
                const slippageFactor = web3.utils.toBN(1000 - defaultSlippage * 1000);
                const amountOutMin = output.mul(slippageFactor).div(web3.utils.toBN(1000));
                const gasPrice = await web3.eth.getGasPrice();
                const adjustedGasPrice = web3.utils.toBN(gasPrice).mul(web3.utils.toBN(15)).div(web3.utils.toBN(10));
                const gasLimit = 3000000; // High gas limit from reference code
                const deadline = Math.floor(Date.now() / 1000) + 60 * 20;
                if (isFromOKB) {
                    const totalValue = web3.utils.toBN(amountInWei).add(web3.utils.toBN(flatFee));
                    await router.methods.swapExactETHForTokensSupportingFeeOnTransferTokens(
                        amountOutMin.toString(),
                        path,
                        account,
                        deadline
                    ).send({ from: account, gasPrice: adjustedGasPrice, gas: gasLimit, value: totalValue });
                } else {
                    await approveToken(fromToken.address, amountInWei);
                    await router.methods.swapExactTokensForETHSupportingFeeOnTransferTokens(
                        amountInWei.toString(),
                        amountOutMin.toString(),
                        path,
                        account,
                        deadline
                    ).send({ from: account, gasPrice: adjustedGasPrice, gas: gasLimit, value: flatFee });
                }
                status.innerHTML = `Swap successful! <a href="${xLayer.blockExplorerUrls[0]}/tx/${tx.transactionHash}" target="_blank">View on explorer</a>`;
                jaceMessage.innerText = getRandomMessage('swapSuccess');
                document.getElementById('fromAmount').value = '';
                await updateBalances();
            } catch (error) {
                console.error("Swap failed:", error);
                let errorMessage = error.message || "Unknown error";
                if (error.message.includes("User denied transaction signature")) {
                    errorMessage = "User denied transaction signature.";
                    jaceMessage.innerText = getRandomMessage('userDenied');
                } else if (error.message.includes("INSUFFICIENT_OUTPUT_AMOUNT") || error.message.includes("EXCESSIVE_INPUT_AMOUNT")) {
                    errorMessage = "Swap failed: Price impact or slippage too high.";
                    jaceMessage.innerText = "Jace says: Swap failed—too much price impact or slippage.";
                } else if (error.message.includes("INSUFFICIENT_LIQUIDITY")) {
                    errorMessage = "Swap failed: Insufficient liquidity in the pool.";
                    jaceMessage.innerText = getRandomMessage('insufficientLiquidity');
                } else if (error.message.includes("out of gas")) {
                    errorMessage = "Swap failed: Out of gas. Try increasing gas limit.";
                    jaceMessage.innerText = "Jace says: Ran out of gas, boost the limit!";
                } else if (error.message.includes("WOOF_LP: K")) {
                    errorMessage = "Swap failed: Insufficient liquidity or invalid K invariant.";
                    jaceMessage.innerText = getRandomMessage('insufficientLiquidity');
                } else {
                    jaceMessage.innerText = getRandomMessage('swapFail');
                }
                status.innerText = errorMessage;
            } finally {
                swapSection.classList.remove('loading');
                swapButton.disabled = false;
            }
        }
    </script>
</body>
</html>
